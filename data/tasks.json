{
  "tasks": [
    {
      "id": "39dd81cf-d2f1-4500-8890-45e1b512d805",
      "name": "環境設置與配置",
      "description": "設置專案的測試環境，安裝必要的依賴項，並配置基本框架結構。包括Playwright、測試資料庫和報告工具的設置。",
      "status": "待處理",
      "dependencies": [],
      "createdAt": "2025-04-19T12:56:27.415Z",
      "updatedAt": "2025-04-19T12:56:27.415Z",
      "implementationGuide": "1. 在專案根目錄中創建 `tests` 資料夾，其中包含 `e2e`、`integration` 和 `unit` 子資料夾\n2. 安裝必要的依賴項：\n   ```bash\n   npm install --save-dev playwright playwright-mcp-server @playwright/test\n   ```\n3. 創建基本配置文件 `playwright.config.js`：\n   ```javascript\n   // playwright.config.js\n   const { defineConfig } = require('@playwright/test');\n\n   module.exports = defineConfig({\n     testDir: './tests/e2e',\n     timeout: 30000,\n     retries: 2,\n     use: {\n       headless: false,\n       viewport: { width: 1280, height: 720 },\n       launchOptions: {\n         slowMo: 50,\n       },\n       trace: 'on-first-retry',\n       screenshot: 'only-on-failure',\n       video: 'on-first-retry'\n     },\n     projects: [\n       {\n         name: 'Chrome',\n         use: { browserName: 'chromium' },\n       },\n       {\n         name: 'Firefox',\n         use: { browserName: 'firefox' },\n       },\n       {\n         name: 'Safari',\n         use: { browserName: 'webkit' },\n       },\n       {\n         name: 'Mobile Chrome',\n         use: {\n           browserName: 'chromium',\n           ...devices['Pixel 5'],\n         },\n       },\n       {\n         name: 'Mobile Safari',\n         use: {\n           browserName: 'webkit',\n           ...devices['iPhone 12'],\n         },\n       },\n     ],\n   });\n   ```\n4. 創建測試資料庫連接配置 `tests/test-db-config.js`:\n   ```javascript\n   // tests/test-db-config.js\n   module.exports = {\n     testDatabase: {\n       client: 'sqlite3',\n       connection: {\n         filename: './tests/data/test.db'\n       },\n       useNullAsDefault: true\n     },\n     resultDatabase: {\n       client: 'sqlite3',\n       connection: {\n         filename: './tests/data/results.db'\n       },\n       useNullAsDefault: true\n     }\n   };\n   ```\n5. 建立基本目錄結構:\n   ```\n   tests/\n     e2e/              # 端到端測試\n     integration/      # 整合測試\n     unit/             # 單元測試\n     fixtures/         # 測試數據\n     utils/            # 測試工具\n     data/             # 測試結果數據\n     reports/          # 報告輸出目錄\n   ```",
      "analysisResult": "為Chat with Me專案設計並實現整合shrimp-task-manager和playwright-mcp-server的自動化測試框架，覆蓋所有核心功能模組並提供自動化錯誤報告和修復流程。此測試框架將使用多層架構，包含測試任務管理系統、自動化測試執行引擎、系統整合層和報告與監控系統。"
    },
    {
      "id": "ce87cae4-99d9-4cbf-bf89-a8fb59543126",
      "name": "測試任務管理系統設計與實現",
      "description": "建立基於shrimp-task-manager的測試任務管理系統，包括測試任務的創建、追蹤、分類和優先級管理。此系統將作為測試流程的核心調度中心。",
      "status": "待處理",
      "dependencies": [],
      "createdAt": "2025-04-19T12:56:27.415Z",
      "updatedAt": "2025-04-19T12:56:27.415Z",
      "implementationGuide": "1. 創建測試任務管理系統的核心模塊 `tests/utils/task-manager.js`:\n\n```javascript\n// tests/utils/task-manager.js\nconst EventEmitter = require('events');\nconst fs = require('fs/promises');\nconst path = require('path');\n\nclass TestTaskManager {\n  constructor(config = {}) {\n    this.config = {\n      tasksDir: path.join(process.cwd(), 'tests', 'tasks'),\n      ...config\n    };\n    this.eventEmitter = new EventEmitter();\n    this.init();\n  }\n\n  async init() {\n    try {\n      await fs.mkdir(this.config.tasksDir, { recursive: true });\n    } catch (error) {\n      console.error('Error initializing task manager:', error);\n    }\n  }\n\n  // 建立測試任務\n  async createTestTask(taskData) {\n    const { name, description, priority = 'medium', module, testScript, config = {} } = taskData;\n    const id = Date.now().toString();\n    const task = {\n      id,\n      name,\n      description,\n      priority,\n      module,\n      testScript,\n      config,\n      status: 'pending',\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    };\n\n    await this.saveTask(task);\n    this.eventEmitter.emit('task:created', task);\n    return task;\n  }\n\n  // 獲取待執行的測試任務\n  async getPendingTestTasks() {\n    const tasks = await this.getAllTasks();\n    return tasks.filter(task => task.status === 'pending');\n  }\n\n  // 更新任務狀態\n  async updateTaskStatus(taskId, status) {\n    const task = await this.getTaskById(taskId);\n    if (!task) {\n      throw new Error(`Task with ID ${taskId} not found`);\n    }\n\n    const updatedTask = {\n      ...task,\n      status,\n      updatedAt: new Date().toISOString()\n    };\n\n    await this.saveTask(updatedTask);\n    this.eventEmitter.emit('task:updated', updatedTask);\n    return updatedTask;\n  }\n\n  // 創建錯誤修復任務\n  async createErrorTask(errorData) {\n    const { taskId, error, screenshot, logs } = errorData;\n    const originalTask = await this.getTaskById(taskId);\n    if (!originalTask) {\n      throw new Error(`Original task with ID ${taskId} not found`);\n    }\n\n    const fixTask = {\n      id: `fix-${Date.now()}`,\n      name: `Fix for: ${originalTask.name}`,\n      description: `Error: ${error}\\nOriginal Task: ${originalTask.description}`,\n      priority: 'high',\n      module: originalTask.module,\n      originalTaskId: taskId,\n      error,\n      evidence: {\n        screenshot,\n        logs\n      },\n      status: 'pending',\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    };\n\n    await this.saveTask(fixTask);\n    this.eventEmitter.emit('task:error', fixTask);\n    return fixTask;\n  }\n\n  // 獲取所有任務\n  async getAllTasks() {\n    try {\n      const files = await fs.readdir(this.config.tasksDir);\n      const tasks = [];\n\n      for (const file of files) {\n        if (file.endsWith('.json')) {\n          const filePath = path.join(this.config.tasksDir, file);\n          const data = await fs.readFile(filePath, 'utf8');\n          tasks.push(JSON.parse(data));\n        }\n      }\n\n      return tasks;\n    } catch (error) {\n      console.error('Error getting all tasks:', error);\n      return [];\n    }\n  }\n\n  // 通過ID獲取任務\n  async getTaskById(taskId) {\n    const filePath = path.join(this.config.tasksDir, `${taskId}.json`);\n    try {\n      const data = await fs.readFile(filePath, 'utf8');\n      return JSON.parse(data);\n    } catch (error) {\n      console.error(`Error getting task ${taskId}:`, error);\n      return null;\n    }\n  }\n\n  // 保存任務到文件\n  async saveTask(task) {\n    const filePath = path.join(this.config.tasksDir, `${task.id}.json`);\n    try {\n      await fs.writeFile(filePath, JSON.stringify(task, null, 2), 'utf8');\n      return true;\n    } catch (error) {\n      console.error(`Error saving task ${task.id}:`, error);\n      return false;\n    }\n  }\n\n  // 附加報告到任務\n  async attachReportToTask(taskId, report) {\n    const task = await this.getTaskById(taskId);\n    if (!task) {\n      throw new Error(`Task with ID ${taskId} not found`);\n    }\n\n    const updatedTask = {\n      ...task,\n      reports: [...(task.reports || []), report],\n      updatedAt: new Date().toISOString()\n    };\n\n    await this.saveTask(updatedTask);\n    this.eventEmitter.emit('task:report-attached', updatedTask);\n    return updatedTask;\n  }\n\n  // 監聽特定事件\n  on(event, callback) {\n    this.eventEmitter.on(event, callback);\n  }\n}\n\nmodule.exports = TestTaskManager;\n```\n\n2. 創建測試任務模板 `tests/utils/task-templates.js`:\n\n```javascript\n// tests/utils/task-templates.js\nmodule.exports = {\n  // 身份驗證測試任務模板\n  authenticationTest: (config = {}) => ({\n    name: 'Authentication Flow Test',\n    description: 'Tests the complete authentication flow including registration, login, and password reset.',\n    priority: 'high',\n    module: 'authentication',\n    testScript: 'auth-flow.test.js',\n    config: {\n      userCredentials: {\n        email: 'test@example.com',\n        password: 'Test@1234'\n      },\n      ...config\n    }\n  }),\n  \n  // 聊天功能測試任務模板\n  chatFunctionalityTest: (config = {}) => ({\n    name: 'Chat Functionality Test',\n    description: 'Tests the chat creation, message sending and receiving, and file sharing features.',\n    priority: 'high',\n    module: 'chat',\n    testScript: 'chat-functionality.test.js',\n    config: {\n      messageContent: 'This is a test message',\n      ...config\n    }\n  }),\n  \n  // AI功能測試任務模板\n  aiFeaturesTest: (config = {}) => ({\n    name: 'AI Features Test',\n    description: 'Tests AI-assisted reply suggestions and AI bot interactions.',\n    priority: 'medium',\n    module: 'ai',\n    testScript: 'ai-features.test.js',\n    config: {\n      botPrompt: 'Hello AI bot',\n      ...config\n    }\n  }),\n  \n  // 好友系統測試任務模板\n  friendsSystemTest: (config = {}) => ({\n    name: 'Friends System Test',\n    description: 'Tests friend search, requests, QR code generation, and profile viewing.',\n    priority: 'medium',\n    module: 'friends',\n    testScript: 'friends-system.test.js',\n    config: {\n      searchQuery: 'test',\n      ...config\n    }\n  }),\n  \n  // 支付系統測試任務模板\n  paymentSystemTest: (config = {}) => ({\n    name: 'Payment System Test',\n    description: 'Tests payment flows including top-up, viewing history, and processing payments.',\n    priority: 'high',\n    module: 'payments',\n    testScript: 'payment-system.test.js',\n    config: {\n      paymentAmount: 10,\n      ...config\n    }\n  })\n};\n```\n\n3. 創建用於初始化測試任務的腳本 `tests/setup-test-tasks.js`:\n\n```javascript\n// tests/setup-test-tasks.js\nconst TestTaskManager = require('./utils/task-manager');\nconst taskTemplates = require('./utils/task-templates');\n\nasync function setupTestTasks() {\n  const taskManager = new TestTaskManager();\n  \n  // 創建認證測試任務\n  await taskManager.createTestTask(taskTemplates.authenticationTest());\n  \n  // 創建聊天功能測試任務\n  await taskManager.createTestTask(taskTemplates.chatFunctionalityTest());\n  \n  // 創建AI功能測試任務\n  await taskManager.createTestTask(taskTemplates.aiFeaturesTest());\n  \n  // 創建好友系統測試任務\n  await taskManager.createTestTask(taskTemplates.friendsSystemTest());\n  \n  // 創建支付系統測試任務\n  await taskManager.createTestTask(taskTemplates.paymentSystemTest());\n  \n  console.log('All test tasks have been set up successfully.');\n}\n\nsetupTestTasks().catch(error => {\n  console.error('Error setting up test tasks:', error);\n});\n```\n\n4. 在package.json添加相關腳本:\n\n```json\n\"scripts\": {\n  \"setup-test-tasks\": \"node tests/setup-test-tasks.js\"\n}\n```",
      "analysisResult": "為Chat with Me專案設計並實現整合shrimp-task-manager和playwright-mcp-server的自動化測試框架，覆蓋所有核心功能模組並提供自動化錯誤報告和修復流程。此測試框架將使用多層架構，包含測試任務管理系統、自動化測試執行引擎、系統整合層和報告與監控系統。"
    },
    {
      "id": "8980fa0b-ea22-4922-9645-3c178f6737d2",
      "name": "自動化測試執行引擎開發",
      "description": "根據 Playwright 開發自動化測試執行引擎，用於執行端對端測試與鍵盤鼠標互動模擬。此引擎應能支援多種瀏覽器、多種設備平台並提供完整的錯誤捕獲功能。",
      "status": "待處理",
      "dependencies": [],
      "createdAt": "2025-04-19T12:59:32.604Z",
      "updatedAt": "2025-04-19T12:59:32.604Z",
      "implementationGuide": "1. 創建 Playwright 測試執行器模組 `tests/utils/playwright-runner.js`:\n\n```javascript\n// tests/utils/playwright-runner.js\nconst { chromium, firefox, webkit } = require('playwright');\nconst path = require('path');\nconst fs = require('fs/promises');\n\nclass PlaywrightRunner {\n  constructor(config = {}) {\n    this.config = {\n      baseURL: 'http://localhost:3000',\n      screenshotsDir: path.join(process.cwd(), 'tests', 'results', 'screenshots'),\n      videosDir: path.join(process.cwd(), 'tests', 'results', 'videos'),\n      logsDir: path.join(process.cwd(), 'tests', 'results', 'logs'),\n      headless: process.env.CI ? true : false,\n      ...config\n    };\n    this.browser = null;\n    this.context = null;\n    this.page = null;\n    this.testLogs = [];\n  }\n\n  // 初始化目錄結構\n  async initDirectories() {\n    const dirs = [\n      this.config.screenshotsDir,\n      this.config.videosDir,\n      this.config.logsDir\n    ];\n    \n    for (const dir of dirs) {\n      await fs.mkdir(dir, { recursive: true });\n    }\n  }\n\n  // 啟動瀏覽器\n  async launchBrowser(browserType = 'chromium') {\n    await this.initDirectories();\n    \n    const browsers = {\n      chromium,\n      firefox,\n      webkit\n    };\n    \n    const browser = browsers[browserType] || chromium;\n    this.browser = await browser.launch({\n      headless: this.config.headless\n    });\n    \n    return this.browser;\n  }\n\n  // 創建瀏覽器上下文\n  async createContext(contextConfig = {}) {\n    if (!this.browser) {\n      await this.launchBrowser(contextConfig.browserType);\n    }\n    \n    this.context = await this.browser.newContext({\n      recordVideo: contextConfig.recordVideo ? { dir: this.config.videosDir } : undefined,\n      viewport: contextConfig.viewport || { width: 1280, height: 720 },\n      ...contextConfig\n    });\n    \n    // 設置頁面錯誤監聽\n    this.context.on('page', page => {\n      page.on('console', msg => {\n        if (msg.type() === 'error') {\n          this.testLogs.push({\n            type: 'console-error',\n            text: msg.text(),\n            timestamp: new Date().toISOString()\n          });\n        }\n      });\n      \n      page.on('pageerror', error => {\n        this.testLogs.push({\n          type: 'page-error',\n          text: error.toString(),\n          timestamp: new Date().toISOString()\n        });\n      });\n    });\n    \n    return this.context;\n  }\n\n  // 創建或取得當前頁面\n  async getPage() {\n    if (!this.context) {\n      await this.createContext();\n    }\n    \n    if (!this.page) {\n      this.page = await this.context.newPage();\n    }\n    \n    return this.page;\n  }\n\n  // 實際執行測試\n  async runTest(testScript, testConfig = {}) {\n    try {\n      const testModulePath = path.join(process.cwd(), 'tests', 'e2e', testScript);\n      const testModule = require(testModulePath);\n      \n      // 清除之前的日誌\n      this.testLogs = [];\n      \n      // 設置測試環境\n      const browserType = testConfig.browserType || 'chromium';\n      await this.launchBrowser(browserType);\n      await this.createContext(testConfig);\n      const page = await this.getPage();\n      \n      // 記錄測試開始\n      const testStartTime = Date.now();\n      this.testLogs.push({\n        type: 'info',\n        text: `Starting test: ${testScript}`,\n        timestamp: new Date().toISOString()\n      });\n      \n      // 執行測試\n      const result = await testModule(page, this, testConfig);\n      \n      // 記錄測試完成\n      const testEndTime = Date.now();\n      const testDuration = testEndTime - testStartTime;\n      \n      this.testLogs.push({\n        type: 'info',\n        text: `Test completed: ${testScript}`,\n        timestamp: new Date().toISOString(),\n        duration: testDuration\n      });\n      \n      return {\n        status: 'passed',\n        duration: testDuration,\n        logs: this.testLogs,\n        result\n      };\n    } catch (error) {\n      // 記錄測試失敗\n      this.testLogs.push({\n        type: 'error',\n        text: error.toString(),\n        stack: error.stack,\n        timestamp: new Date().toISOString()\n      });\n      \n      // 拍攝錯誤畫面\n      await this.takeScreenshot(`error-${Date.now()}`);\n      \n      throw error;\n    } finally {\n      await this.closeBrowser();\n    }\n  }\n\n  // 截取畫面\n  async takeScreenshot(name) {\n    if (!this.page) {\n      throw new Error('No active page');\n    }\n    \n    const screenshotPath = path.join(this.config.screenshotsDir, `${name}.png`);\n    await this.page.screenshot({ path: screenshotPath, fullPage: true });\n    return screenshotPath;\n  }\n\n  // 獲取日誌\n  async getLogs() {\n    const logFilePath = path.join(this.config.logsDir, `test-log-${Date.now()}.json`);\n    await fs.writeFile(logFilePath, JSON.stringify(this.testLogs, null, 2), 'utf8');\n    return {\n      logs: this.testLogs,\n      path: logFilePath\n    };\n  }\n\n  // 獲取環境信息\n  async getEnvironmentInfo() {\n    return {\n      browser: this.browser ? await this.browser.version() : null,\n      platform: process.platform,\n      time: new Date().toISOString(),\n      config: this.config\n    };\n  }\n\n  // 關閉瀏覽器\n  async closeBrowser() {\n    if (this.browser) {\n      await this.browser.close();\n      this.browser = null;\n      this.context = null;\n      this.page = null;\n    }\n  }\n}\n\nmodule.exports = PlaywrightRunner;\n```\n\n2. 創建測試案例建构器 `tests/utils/test-case-builder.js`:\n\n```javascript\n// tests/utils/test-case-builder.js\nclass TestCaseBuilder {\n  constructor(baseUrl, config = {}) {\n    this.baseUrl = baseUrl;\n    this.config = config;\n    this.steps = [];\n  }\n  \n  // 訪問URL\n  navigate(path) {\n    this.steps.push({\n      type: 'navigation',\n      path: path\n    });\n    return this;\n  }\n  \n  // 輸入文本\n  type(selector, text) {\n    this.steps.push({\n      type: 'input',\n      selector: selector,\n      text: text\n    });\n    return this;\n  }\n  \n  // 點擊元素\n  click(selector) {\n    this.steps.push({\n      type: 'click',\n      selector: selector\n    });\n    return this;\n  }\n  \n  // 等待元素出現\n  waitForSelector(selector, options = {}) {\n    this.steps.push({\n      type: 'wait',\n      selector: selector,\n      options: options\n    });\n    return this;\n  }\n  \n  // 驗證元素內容\n  expectContent(selector, expectedText) {\n    this.steps.push({\n      type: 'assertion',\n      selector: selector,\n      expectedText: expectedText\n    });\n    return this;\n  }\n  \n  // 檢查元素是否存在\n  expectExists(selector, shouldExist = true) {\n    this.steps.push({\n      type: 'existence',\n      selector: selector,\n      shouldExist: shouldExist\n    });\n    return this;\n  }\n  \n  // 測試URL路徑\n  expectUrl(urlPattern) {\n    this.steps.push({\n      type: 'url',\n      urlPattern: urlPattern\n    });\n    return this;\n  }\n  \n  // 等待指定時間\n  wait(milliseconds) {\n    this.steps.push({\n      type: 'wait-time',\n      milliseconds: milliseconds\n    });\n    return this;\n  }\n  \n  // 填寫表單\n  fillForm(formSelector, fields) {\n    this.steps.push({\n      type: 'form',\n      formSelector: formSelector,\n      fields: fields\n    });\n    return this;\n  }\n  \n  // 截圖\n  screenshot(name) {\n    this.steps.push({\n      type: 'screenshot',\n      name: name\n    });\n    return this;\n  }\n  \n  // 生成可執行的測試腳本\n  buildScript(name, description = '') {\n    return {\n      name,\n      description,\n      baseUrl: this.baseUrl,\n      steps: this.steps,\n      config: this.config\n    };\n  }\n  \n  // 將測試腳本轉換為 Playwright 實際代碼\n  generatePlaywrightTest() {\n    return async (page, runner, config = {}) => {\n      const baseUrl = config.baseUrl || this.baseUrl;\n      \n      for (const step of this.steps) {\n        switch (step.type) {\n          case 'navigation':\n            await page.goto(`${baseUrl}${step.path}`);\n            break;\n            \n          case 'input':\n            await page.fill(step.selector, step.text);\n            break;\n            \n          case 'click':\n            await page.click(step.selector);\n            break;\n            \n          case 'wait':\n            await page.waitForSelector(step.selector, step.options);\n            break;\n            \n          case 'assertion':\n            const content = await page.textContent(step.selector);\n            if (!content.includes(step.expectedText)) {\n              throw new Error(`Expected \"${step.selector}\" to contain \"${step.expectedText}\", but found \"${content}\"`);\n            }\n            break;\n            \n          case 'existence':\n            const exists = await page.$(step.selector) !== null;\n            if (exists !== step.shouldExist) {\n              throw new Error(`Expected element \"${step.selector}\" ${step.shouldExist ? 'to exist' : 'not to exist'}`);\n            }\n            break;\n            \n          case 'url':\n            const url = page.url();\n            if (!url.match(step.urlPattern)) {\n              throw new Error(`Expected URL to match \"${step.urlPattern}\", but found \"${url}\"`);\n            }\n            break;\n            \n          case 'wait-time':\n            await page.waitForTimeout(step.milliseconds);\n            break;\n            \n          case 'form':\n            for (const [fieldSelector, value] of Object.entries(step.fields)) {\n              await page.fill(`${step.formSelector} ${fieldSelector}`, value);\n            }\n            break;\n            \n          case 'screenshot':\n            await runner.takeScreenshot(step.name);\n            break;\n            \n          default:\n            throw new Error(`Unknown step type: ${step.type}`);\n        }\n      }\n      \n      return { success: true };\n    };\n  }\n}\n\nmodule.exports = TestCaseBuilder;\n```\n\n3. 創建一個基本的測試例子 `tests/e2e/auth-flow.test.js`:\n\n```javascript\n// tests/e2e/auth-flow.test.js\nconst TestCaseBuilder = require('../utils/test-case-builder');\n\nmodule.exports = async (page, runner, config) => {\n  const { userCredentials } = config;\n  const results = { steps: {} };\n  \n  // 訪問登入頁\n  await page.goto(`${config.baseUrl || 'http://localhost:3000'}/auth/login`);\n  results.steps.navigate = 'passed';\n  \n  // 確保登入表單存在\n  await page.waitForSelector('form[action*=\"login\"]');\n  results.steps.loginFormVisible = 'passed';\n  \n  // 輸入使用者應計\n  await page.fill('input[type=\"email\"]', userCredentials.email);\n  await page.fill('input[type=\"password\"]', userCredentials.password);\n  results.steps.fillCredentials = 'passed';\n  \n  // 截圖登入表單\n  await runner.takeScreenshot('login-form-filled');\n  \n  // 點擊登入按鈕\n  await page.click('button[type=\"submit\"]');\n  results.steps.clickLogin = 'passed';\n  \n  // 等待導向到儀表板頁面\n  try {\n    await page.waitForNavigation({ url: '**/dashboard**' });\n    results.steps.redirectToDashboard = 'passed';\n  } catch (error) {\n    results.steps.redirectToDashboard = 'failed';\n    throw new Error('Failed to redirect to dashboard after login');\n  }\n  \n  // 確認登入成功\n  await page.waitForSelector('h1:has-text(\"Dashboard\")');\n  results.steps.dashboardVisible = 'passed';\n  \n  // 截圖儀表板\n  await runner.takeScreenshot('dashboard-after-login');\n  \n  return results;\n};\n```\n\n4. 將Playwright測試執行器整合到專案中:\n\n```javascript\n// tests/run-single-test.js\nconst PlaywrightRunner = require('./utils/playwright-runner');\n\nasync function runSingleTest(testScript, config = {}) {\n  const runner = new PlaywrightRunner({\n    baseURL: config.baseURL || 'http://localhost:3000'\n  });\n  \n  try {\n    const result = await runner.runTest(testScript, config);\n    console.log(`Test ${testScript} ${result.status}!`);\n    console.log(`Duration: ${result.duration}ms`);\n    return result;\n  } catch (error) {\n    console.error(`Test ${testScript} failed:`, error);\n    const logs = await runner.getLogs();\n    console.log(`Logs saved to: ${logs.path}`);\n    throw error;\n  } finally {\n    await runner.closeBrowser();\n  }\n}\n\n// 如果直接執行腳本\n if (require.main === module) {\n  const testScript = process.argv[2];\n  const configStr = process.argv[3] || '{}';\n  \n  if (!testScript) {\n    console.error('Usage: node run-single-test.js <test-script> [config-json]');\n    process.exit(1);\n  }\n  \n  let config;\n  try {\n    config = JSON.parse(configStr);\n  } catch (e) {\n    console.error('Invalid config JSON:', e);\n    process.exit(1);\n  }\n  \n  runSingleTest(testScript, config)\n    .then(() => process.exit(0))\n    .catch(() => process.exit(1));\n}\n\nmodule.exports = runSingleTest;\n```\n\n5. 在package.json中添加腳本:\n\n```json\n\"scripts\": {\n  \"test:e2e\": \"node tests/run-single-test.js\"\n}\n```",
      "analysisResult": "為Chat with Me專案設計並實現整合shrimp-task-manager和playwright-mcp-server的自動化測試框架，覆蓋所有核心功能模組並提供自動化錯誤報告和修復流程。"
    },
    {
      "id": "bce89c50-691a-40e8-8606-eead270705e4",
      "name": "系統整合層開發",
      "description": "進行 shrimp-task-manager 和 playwright-mcp-server 之間的整合，建立中間件連接兩個系統，實現自動化測試執行、錯誤報告和修復任務管理。",
      "status": "待處理",
      "dependencies": [],
      "createdAt": "2025-04-19T13:00:55.370Z",
      "updatedAt": "2025-04-19T13:00:55.370Z",
      "implementationGuide": "1. 創建系統整合層主模塊 `tests/utils/integration-middleware.js`:\n\n```javascript\n// tests/utils/integration-middleware.js\nconst EventEmitter = require('events');\nconst path = require('path');\nconst fs = require('fs/promises');\n\nclass TestingIntegrationMiddleware {\n  constructor(taskManagerClient, playwrightClient, config = {}) {\n    this.taskManager = taskManagerClient;\n    this.playwright = playwrightClient;\n    this.config = {\n      reportDir: path.join(process.cwd(), 'tests', 'reports'),\n      ...config\n    };\n    this.eventBus = new EventEmitter();\n    this.setupEventListeners();\n  }\n\n  // 初始化目錄\n  async init() {\n    try {\n      await fs.mkdir(this.config.reportDir, { recursive: true });\n    } catch (error) {\n      console.error('Error initializing integration middleware:', error);\n    }\n  }\n\n  // 從 shrimp-task-manager 獲取測試任務並安排執行\n  async scheduleTasks() {\n    const tasks = await this.taskManager.getPendingTestTasks();\n    this.eventBus.emit('tasks:scheduled', tasks);\n    return this.executeTests(tasks);\n  }\n\n  // 使用 playwright 執行測試\n  async executeTests(tasks) {\n    const results = [];\n    \n    for (const task of tasks) {\n      try {\n        // 更新任務狀態為「進行中」\n        await this.taskManager.updateTaskStatus(task.id, 'in-progress');\n        this.eventBus.emit('test:running', { taskId: task.id });\n        \n        // 執行測試\n        const result = await this.playwright.runTest(task.testScript, task.config);\n        \n        // 記錄成功結果\n        const successData = { \n          taskId: task.id, \n          status: 'completed', \n          result \n        };\n        \n        results.push(successData);\n        this.eventBus.emit('test:completed', successData);\n      } catch (error) {\n        // 處理測試失敗\n        const screenshot = await this.playwright.takeScreenshot(`error-${task.id}`);\n        const logs = await this.playwright.getLogs();\n        \n        const errorData = {\n          taskId: task.id,\n          status: 'failed',\n          error: error.message,\n          stack: error.stack,\n          screenshot,\n          logs\n        };\n        \n        results.push(errorData);\n        this.eventBus.emit('test:failed', errorData);\n        \n        // 自動創建錯誤修復任務\n        await this.taskManager.createErrorTask(errorData);\n      }\n    }\n    \n    return results;\n  }\n\n  // 重新執行失敗的測試\n  async retryFailedTests() {\n    // 獲取所有失敗的測試任務\n    const allTasks = await this.taskManager.getAllTasks();\n    const failedTasks = allTasks.filter(task => task.status === 'failed');\n    \n    if (failedTasks.length === 0) {\n      console.log('No failed tests to retry');\n      return [];\n    }\n    \n    console.log(`Retrying ${failedTasks.length} failed tests...`);\n    \n    // 重新執行失敗的測試\n    return this.executeTests(failedTasks);\n  }\n\n  // 監聽測試完成事件，更新任務狀態\n  setupEventListeners() {\n    this.eventBus.on('test:completed', async (data) => {\n      await this.taskManager.updateTaskStatus(data.taskId, 'completed');\n      await this.generateSuccessReport(data);\n    });\n    \n    this.eventBus.on('test:failed', async (data) => {\n      await this.taskManager.updateTaskStatus(data.taskId, 'failed');\n      await this.generateErrorReport(data);\n    });\n    \n    this.eventBus.on('tasks:scheduled', (tasks) => {\n      console.log(`Scheduled ${tasks.length} tasks for execution`);\n    });\n  }\n\n  // 生成成功報告\n  async generateSuccessReport(data) {\n    const reportPath = path.join(this.config.reportDir, `success-${data.taskId}-${Date.now()}.json`);\n    const report = {\n      taskId: data.taskId,\n      timestamp: new Date().toISOString(),\n      status: 'completed',\n      duration: data.result.duration,\n      testEnvironment: await this.playwright.getEnvironmentInfo()\n    };\n    \n    await fs.writeFile(reportPath, JSON.stringify(report, null, 2), 'utf8');\n    await this.taskManager.attachReportToTask(data.taskId, {\n      type: 'success',\n      path: reportPath,\n      timestamp: new Date().toISOString()\n    });\n    \n    return report;\n  }\n\n  // 生成錯誤報告\n  async generateErrorReport(errorData) {\n    // 對於錯誤案例，我們創建一個更詳細的報告\n    const reportPath = path.join(this.config.reportDir, `error-${errorData.taskId}-${Date.now()}.json`);\n    \n    // 如果提供了畫面截圖路徑，保存截圖的相對路徑\n    let screenshotPath = null;\n    if (errorData.screenshot) {\n      screenshotPath = path.relative(process.cwd(), errorData.screenshot);\n    }\n    \n    // 如果提供了日誌路徑，保存日誌的相對路徑\n    let logsPath = null;\n    if (errorData.logs && errorData.logs.path) {\n      logsPath = path.relative(process.cwd(), errorData.logs.path);\n    }\n    \n    const report = {\n      taskId: errorData.taskId,\n      timestamp: new Date().toISOString(),\n      status: 'failed',\n      error: errorData.error,\n      stack: errorData.stack,\n      screenshotPath,\n      logsPath,\n      testEnvironment: await this.playwright.getEnvironmentInfo()\n    };\n    \n    await fs.writeFile(reportPath, JSON.stringify(report, null, 2), 'utf8');\n    await this.taskManager.attachReportToTask(errorData.taskId, {\n      type: 'error',\n      path: reportPath,\n      timestamp: new Date().toISOString()\n    });\n    \n    return report;\n  }\n\n  // 監聽特定事件\n  on(event, callback) {\n    this.eventBus.on(event, callback);\n  }\n}\n\nmodule.exports = TestingIntegrationMiddleware;\n```\n\n2. 創建自動化測試執行腳本 `tests/run-automated-tests.js`:\n\n```javascript\n// tests/run-automated-tests.js\nconst TestTaskManager = require('./utils/task-manager');\nconst PlaywrightRunner = require('./utils/playwright-runner');\nconst TestingIntegrationMiddleware = require('./utils/integration-middleware');\n\nasync function runAutomatedTests() {\n  try {\n    // 初始化元件\n    const taskManager = new TestTaskManager();\n    const playwrightRunner = new PlaywrightRunner();\n    const middleware = new TestingIntegrationMiddleware(taskManager, playwrightRunner);\n    \n    await middleware.init();\n    \n    // 添加事件監聽器來追蹤測試進度\n    middleware.on('test:running', (data) => {\n      console.log(`Running test: ${data.taskId}`);\n    });\n    \n    middleware.on('test:completed', (data) => {\n      console.log(`Completed test: ${data.taskId}`);\n    });\n    \n    middleware.on('test:failed', (data) => {\n      console.error(`Failed test: ${data.taskId} - ${data.error}`);\n    });\n    \n    // 獲取並執行所有待處理的測試任務\n    console.log('Starting automated test execution...');\n    const results = await middleware.scheduleTasks();\n    \n    // 輸出測試結果統計\n    const totalTests = results.length;\n    const passedTests = results.filter(r => r.status === 'completed').length;\n    const failedTests = results.filter(r => r.status === 'failed').length;\n    \n    console.log('\\nTest Execution Summary:');\n    console.log(`Total Tests: ${totalTests}`);\n    console.log(`Passed: ${passedTests}`);\n    console.log(`Failed: ${failedTests}`);\n    console.log(`Pass Rate: ${Math.round((passedTests / totalTests) * 100)}%`);\n    \n    // 獲取報告路徑\n    console.log('\\nDetailed reports available at:');\n    console.log(`${middleware.config.reportDir}`);\n    \n    // 根據需要重新執行失敗的測試\n    if (failedTests > 0 && process.argv.includes('--retry')) {\n      console.log('\\nRetrying failed tests...');\n      const retryResults = await middleware.retryFailedTests();\n      \n      const retryPassed = retryResults.filter(r => r.status === 'completed').length;\n      console.log(`Retry results: ${retryPassed}/${retryResults.length} tests passed on retry.`);\n    }\n    \n    return results;\n  } catch (error) {\n    console.error('Error running automated tests:', error);\n    throw error;\n  }\n}\n\n// 如果直接執行腳本\n if (require.main === module) {\n  runAutomatedTests()\n    .then(() => process.exit(0))\n    .catch((error) => {\n      console.error('Test automation failed:', error);\n      process.exit(1);\n    });\n}\n\nmodule.exports = runAutomatedTests;\n```\n\n3. 建立對 playwright-mcp-server 的整合模塊 `tests/utils/playwright-mcp-integration.js`:\n\n```javascript\n// tests/utils/playwright-mcp-integration.js\nconst EventEmitter = require('events');\n\nclass PlaywrightMCPIntegration {\n  constructor(config = {}) {\n    this.config = {\n      serverEndpoint: process.env.PLAYWRIGHT_MCP_SERVER || 'http://localhost:8080',\n      ...config\n    };\n    this.eventEmitter = new EventEmitter();\n  }\n  \n  // 向 playwright-mcp-server 報告錯誤\n  async reportError(errorData) {\n    try {\n      console.log(`Reporting error to Playwright MCP server: ${errorData.error}`);\n      \n      // TODO: 實施實際的 API 調用以報告錯誤\n      // 這裡是使用模擬的報告機制\n      \n      this.eventEmitter.emit('error:reported', {\n        taskId: errorData.taskId,\n        timestamp: new Date().toISOString(),\n        error: errorData.error\n      });\n      \n      return true;\n    } catch (error) {\n      console.error('Error reporting to Playwright MCP server:', error);\n      return false;\n    }\n  }\n  \n  // 開始監控測試結果\n  async startMonitoring(middleware) {\n    // 監聽中間件的錯誤事件\n    middleware.on('test:failed', async (errorData) => {\n      await this.reportError(errorData);\n    });\n    \n    console.log('Playwright MCP monitoring started');\n    \n    return () => {\n      // 返回停止監控的函數\n      console.log('Playwright MCP monitoring stopped');\n    };\n  }\n  \n  // 監聽特定事件\n  on(event, callback) {\n    this.eventEmitter.on(event, callback);\n  }\n}\n\nmodule.exports = PlaywrightMCPIntegration;\n```\n\n4. 更新自動化測試執行腳本以整合監控 `tests/run-with-monitoring.js`:\n\n```javascript\n// tests/run-with-monitoring.js\nconst TestTaskManager = require('./utils/task-manager');\nconst PlaywrightRunner = require('./utils/playwright-runner');\nconst TestingIntegrationMiddleware = require('./utils/integration-middleware');\nconst PlaywrightMCPIntegration = require('./utils/playwright-mcp-integration');\n\nasync function runTestsWithMonitoring() {\n  let stopMonitoring = null;\n  \n  try {\n    // 初始化元件\n    const taskManager = new TestTaskManager();\n    const playwrightRunner = new PlaywrightRunner();\n    const middleware = new TestingIntegrationMiddleware(taskManager, playwrightRunner);\n    const mcpIntegration = new PlaywrightMCPIntegration();\n    \n    await middleware.init();\n    \n    // 開始監控\n    stopMonitoring = await mcpIntegration.startMonitoring(middleware);\n    \n    // 添加 MCP 監控相關的事件監聽器\n    mcpIntegration.on('error:reported', (data) => {\n      console.log(`Error reported to MCP: ${data.error}`);\n    });\n    \n    // 獲取並執行所有待處理的測試任務\n    console.log('Starting tests with MCP monitoring...');\n    const results = await middleware.scheduleTasks();\n    \n    // 輸出測試結果統計\n    const totalTests = results.length;\n    const passedTests = results.filter(r => r.status === 'completed').length;\n    const failedTests = results.filter(r => r.status === 'failed').length;\n    \n    console.log('\\nTest Execution Summary:');\n    console.log(`Total Tests: ${totalTests}`);\n    console.log(`Passed: ${passedTests}`);\n    console.log(`Failed: ${failedTests}`);\n    console.log(`Pass Rate: ${Math.round((passedTests / totalTests) * 100)}%`);\n    \n    return results;\n  } catch (error) {\n    console.error('Error running tests with monitoring:', error);\n    throw error;\n  } finally {\n    // 確保停止監控\n    if (stopMonitoring) {\n      stopMonitoring();\n    }\n  }\n}\n\n// 如果直接執行腳本\n if (require.main === module) {\n  runTestsWithMonitoring()\n    .then(() => process.exit(0))\n    .catch((error) => {\n      console.error('Test automation with monitoring failed:', error);\n      process.exit(1);\n    });\n}\n\nmodule.exports = runTestsWithMonitoring;\n```\n\n5. 在 package.json 中添加相關腳本:\n\n```json\n\"scripts\": {\n  \"test:automated\": \"node tests/run-automated-tests.js\",\n  \"test:with-monitoring\": \"node tests/run-with-monitoring.js\"\n}\n```",
      "analysisResult": "為Chat with Me專案設計並實現整合shrimp-task-manager和playwright-mcp-server的自動化測試框架，覆蓋所有核心功能模組並提供自動化錯誤報告和修復流程。"
    },
    {
      "id": "20e02ae1-433f-4ad4-b127-fea47a1d1230",
      "name": "測試報告與監控系統開發",
      "description": "開發測試報告與監控系統，提供圖形化的測試結果呈現、覆蓋率分析和錯誤追蹤功能。",
      "status": "待處理",
      "dependencies": [],
      "createdAt": "2025-04-19T13:05:56.279Z",
      "updatedAt": "2025-04-19T13:05:56.279Z",
      "implementationGuide": "1. 創建測試報告系統模塊 `tests/utils/test-reporting.js`:\n\n```javascript\n// tests/utils/test-reporting.js\nconst fs = require('fs/promises');\nconst path = require('path');\n\nclass TestReportingSystem {\n  constructor(config = {}) {\n    this.config = {\n      reportDir: path.join(process.cwd(), 'tests', 'reports'),\n      ...config\n    };\n    this.db = null; // 將使用文件系統做為簡單的數據存儲\n  }\n\n  // 初始化報告系統\n  async init() {\n    try {\n      await fs.mkdir(this.config.reportDir, { recursive: true });\n      // 確保結果存儲文件存在\n      const dbFile = path.join(this.config.reportDir, 'results.json');\n      try {\n        await fs.access(dbFile);\n      } catch (e) {\n        // 文件不存在，創建初始數據\n        await fs.writeFile(dbFile, JSON.stringify({\n          test_results: [],\n          last_updated: new Date().toISOString()\n        }, null, 2), 'utf8');\n      }\n    } catch (error) {\n      console.error('Error initializing reporting system:', error);\n    }\n  }\n\n  // 記錄測試結果\n  async recordTestResult(result) {\n    try {\n      const dbFile = path.join(this.config.reportDir, 'results.json');\n      const data = JSON.parse(await fs.readFile(dbFile, 'utf8'));\n      \n      // 添加新的測試結果\n      data.test_results.push({\n        ...result,\n        id: Date.now().toString(),\n        recorded_at: new Date().toISOString()\n      });\n      \n      data.last_updated = new Date().toISOString();\n      \n      // 寫回文件\n      await fs.writeFile(dbFile, JSON.stringify(data, null, 2), 'utf8');\n      \n      return true;\n    } catch (error) {\n      console.error('Error recording test result:', error);\n      return false;\n    }\n  }\n\n  // 獲取測試結果\n  async getTestResults(filter = {}) {\n    try {\n      const dbFile = path.join(this.config.reportDir, 'results.json');\n      const data = JSON.parse(await fs.readFile(dbFile, 'utf8'));\n      \n      let results = data.test_results;\n      \n      // 如果有日期範圍過濾條件\n      if (filter.startDate) {\n        const startTime = new Date(filter.startDate).getTime();\n        results = results.filter(r => {\n          const recordTime = new Date(r.recorded_at).getTime();\n          return recordTime >= startTime;\n        });\n      }\n      \n      // 如果有狀態過濾條件\n      if (filter.status) {\n        results = results.filter(r => r.status === filter.status);\n      }\n      \n      // 如果有模塊過濾條件\n      if (filter.module) {\n        results = results.filter(r => r.module === filter.module);\n      }\n      \n      return results;\n    } catch (error) {\n      console.error('Error getting test results:', error);\n      return [];\n    }\n  }\n\n  // 獲取測試覆蓋率指標\n  async getCoverageMetrics(timeframe = 'week') {\n    try {\n      const startDate = this._getTimeframeStartDate(timeframe);\n      \n      // 獲取測試結果\n      const results = await this.getTestResults({ startDate });\n      const modules = [...new Set(results.map(r => r.module))]; // 獲取唯一的模塊列表\n      \n      // 計算各類指標\n      const metrics = {\n        totalTests: results.length,\n        passedTests: results.filter(r => r.status === 'completed').length,\n        failedTests: results.filter(r => r.status === 'failed').length,\n        modulesCovered: modules.length,\n        byModule: {}\n      };\n      \n      // 按模塊分組統計\n      for (const module of modules) {\n        const moduleResults = results.filter(r => r.module === module);\n        metrics.byModule[module] = {\n          total: moduleResults.length,\n          passed: moduleResults.filter(r => r.status === 'completed').length,\n          failed: moduleResults.filter(r => r.status === 'failed').length,\n          passRate: moduleResults.length > 0 \n            ? Math.round((moduleResults.filter(r => r.status === 'completed').length / moduleResults.length) * 100) \n            : 0\n        };\n      }\n      \n      // 計算整體通過率\n      metrics.passRate = metrics.totalTests > 0 \n        ? Math.round((metrics.passedTests / metrics.totalTests) * 100) \n        : 0;\n      \n      return metrics;\n    } catch (error) {\n      console.error('Error calculating coverage metrics:', error);\n      return {\n        totalTests: 0,\n        passedTests: 0,\n        failedTests: 0,\n        modulesCovered: 0,\n        passRate: 0,\n        byModule: {}\n      };\n    }\n  }\n\n  // 生成錯誤趨勢報告\n  async getErrorTrends(timeframe = 'week') {\n    try {\n      const startDate = this._getTimeframeStartDate(timeframe);\n      \n      // 獲取失敗的測試結果\n      const failedResults = await this.getTestResults({ \n        startDate, \n        status: 'failed' \n      });\n      \n      // 按錯誤類型分組\n      const errorsByType = {};\n      for (const result of failedResults) {\n        const errorMessage = result.error || 'Unknown error';\n        // 提取錯誤的第一行作為類型\n        const errorType = errorMessage.split('\\n')[0].substring(0, 100);\n        \n        if (!errorsByType[errorType]) {\n          errorsByType[errorType] = [];\n        }\n        \n        errorsByType[errorType].push(result);\n      }\n      \n      // 生成趨勢報告\n      const trends = {\n        totalErrors: failedResults.length,\n        uniqueErrorTypes: Object.keys(errorsByType).length,\n        topErrors: [],\n        byDay: {}\n      };\n      \n      // 按發生频率排序的錯誤類型\n      trends.topErrors = Object.entries(errorsByType)\n        .map(([type, errors]) => ({\n          type,\n          count: errors.length,\n          percentage: Math.round((errors.length / failedResults.length) * 100)\n        }))\n        .sort((a, b) => b.count - a.count)\n        .slice(0, 5); // 取前5名\n      \n      // 按日期分組\n      const resultsByDay = {};\n      for (const result of failedResults) {\n        const date = new Date(result.recorded_at).toISOString().split('T')[0]; // YYYY-MM-DD\n        \n        if (!resultsByDay[date]) {\n          resultsByDay[date] = [];\n        }\n        \n        resultsByDay[date].push(result);\n      }\n      \n      // 生成每日錯誤統計\n      trends.byDay = Object.entries(resultsByDay).map(([date, results]) => ({\n        date,\n        count: results.length\n      })).sort((a, b) => new Date(a.date) - new Date(b.date));\n      \n      return trends;\n    } catch (error) {\n      console.error('Error generating error trends:', error);\n      return {\n        totalErrors: 0,\n        uniqueErrorTypes: 0,\n        topErrors: [],\n        byDay: []\n      };\n    }\n  }\n\n  // 生成HTML報告\n  async generateHTMLReport(timeframe = 'week') {\n    const coverage = await this.getCoverageMetrics(timeframe);\n    const errorTrends = await this.getErrorTrends(timeframe);\n    \n    const reportPath = path.join(this.config.reportDir, `report-${Date.now()}.html`);\n    const reportHTML = `\n    <!DOCTYPE html>\n    <html>\n    <head>\n      <title>Test Automation Report</title>\n      <style>\n        body { font-family: Arial, sans-serif; line-height: 1.6; padding: 20px; max-width: 1200px; margin: 0 auto; }\n        h1, h2, h3 { color: #333; }\n        .summary { display: flex; justify-content: space-between; margin-bottom: 30px; }\n        .summary-card { background: #f5f5f5; border-radius: 5px; padding: 15px; width: 23%; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n        .pass-rate { font-size: 24px; font-weight: bold; margin-top: 10px; }\n        .pass-rate.good { color: green; }\n        .pass-rate.warning { color: orange; }\n        .pass-rate.bad { color: red; }\n        table { width: 100%; border-collapse: collapse; margin-bottom: 30px; }\n        th, td { padding: 10px; text-align: left; border-bottom: 1px solid #ddd; }\n        th { background-color: #f2f2f2; }\n        .module-table tr:hover { background-color: #f5f5f5; }\n        .error-type { max-width: 500px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }\n      </style>\n    </head>\n    <body>\n      <h1>Test Automation Report</h1>\n      <p>Generated on: ${new Date().toLocaleString()}</p>\n      \n      <h2>Summary</h2>\n      <div class=\"summary\">\n        <div class=\"summary-card\">\n          <h3>Total Tests</h3>\n          <div class=\"pass-rate\">${coverage.totalTests}</div>\n        </div>\n        <div class=\"summary-card\">\n          <h3>Pass Rate</h3>\n          <div class=\"pass-rate ${coverage.passRate > 80 ? 'good' : coverage.passRate > 50 ? 'warning' : 'bad'}\">\n            ${coverage.passRate}%\n          </div>\n        </div>\n        <div class=\"summary-card\">\n          <h3>Modules Covered</h3>\n          <div class=\"pass-rate\">${coverage.modulesCovered}</div>\n        </div>\n        <div class=\"summary-card\">\n          <h3>Error Types</h3>\n          <div class=\"pass-rate ${errorTrends.uniqueErrorTypes > 10 ? 'bad' : errorTrends.uniqueErrorTypes > 5 ? 'warning' : 'good'}\">\n            ${errorTrends.uniqueErrorTypes}\n          </div>\n        </div>\n      </div>\n      \n      <h2>Coverage by Module</h2>\n      <table class=\"module-table\">\n        <tr>\n          <th>Module</th>\n          <th>Total Tests</th>\n          <th>Passed</th>\n          <th>Failed</th>\n          <th>Pass Rate</th>\n        </tr>\n        ${Object.entries(coverage.byModule).map(([module, stats]) => `\n        <tr>\n          <td>${module}</td>\n          <td>${stats.total}</td>\n          <td>${stats.passed}</td>\n          <td>${stats.failed}</td>\n          <td>\n            <span class=\"${stats.passRate > 80 ? 'good' : stats.passRate > 50 ? 'warning' : 'bad'}\">\n              ${stats.passRate}%\n            </span>\n          </td>\n        </tr>\n        `).join('')}\n      </table>\n      \n      <h2>Top Error Types</h2>\n      <table>\n        <tr>\n          <th>Error Type</th>\n          <th>Count</th>\n          <th>Percentage</th>\n        </tr>\n        ${errorTrends.topErrors.map(error => `\n        <tr>\n          <td><div class=\"error-type\" title=\"${error.type}\">${error.type}</div></td>\n          <td>${error.count}</td>\n          <td>${error.percentage}%</td>\n        </tr>\n        `).join('')}\n      </table>\n    </body>\n    </html>\n    `;\n    \n    await fs.writeFile(reportPath, reportHTML, 'utf8');\n    return reportPath;\n  }\n\n  // 生成各種格式的報告\n  async generateReport(format = 'html', timeframe = 'week') {\n    switch (format.toLowerCase()) {\n      case 'html':\n        return this.generateHTMLReport(timeframe);\n        \n      case 'json':\n        const coverage = await this.getCoverageMetrics(timeframe);\n        const errorTrends = await this.getErrorTrends(timeframe);\n        const reportData = {\n          generated_at: new Date().toISOString(),\n          timeframe,\n          coverage,\n          errorTrends\n        };\n        \n        const reportPath = path.join(this.config.reportDir, `report-${Date.now()}.json`);\n        await fs.writeFile(reportPath, JSON.stringify(reportData, null, 2), 'utf8');\n        return reportPath;\n        \n      default:\n        throw new Error(`Unsupported report format: ${format}`);\n    }\n  }\n\n  // 幫助函數：獲取時間區間的開始日期\n  _getTimeframeStartDate(timeframe) {\n    const now = new Date();\n    let startDate;\n    \n    switch (timeframe) {\n      case 'day':\n        startDate = new Date(now);\n        startDate.setHours(0, 0, 0, 0);\n        break;\n        \n      case 'week':\n        startDate = new Date(now);\n        startDate.setDate(now.getDate() - 7);\n        break;\n        \n      case 'month':\n        startDate = new Date(now);\n        startDate.setMonth(now.getMonth() - 1);\n        break;\n        \n      case 'quarter':\n        startDate = new Date(now);\n        startDate.setMonth(now.getMonth() - 3);\n        break;\n        \n      case 'year':\n        startDate = new Date(now);\n        startDate.setFullYear(now.getFullYear() - 1);\n        break;\n        \n      default:\n        // 默認為一週\n        startDate = new Date(now);\n        startDate.setDate(now.getDate() - 7);\n    }\n    \n    return startDate.toISOString();\n  }\n}\n\nmodule.exports = TestReportingSystem;\n```\n\n2. 創建報告生成腳本 `tests/generate-report.js`:\n\n```javascript\n// tests/generate-report.js\nconst TestReportingSystem = require('./utils/test-reporting');\n\nasync function generateTestReport(format = 'html', timeframe = 'week') {\n  try {\n    const reportingSystem = new TestReportingSystem();\n    await reportingSystem.init();\n    \n    console.log(`Generating ${format} report for the last ${timeframe}...`);\n    const reportPath = await reportingSystem.generateReport(format, timeframe);\n    \n    console.log(`Report generated successfully: ${reportPath}`);\n    return reportPath;\n  } catch (error) {\n    console.error('Error generating test report:', error);\n    throw error;\n  }\n}\n\n// 如果直接執行腳本\nif (require.main === module) {\n  const format = process.argv[2] || 'html';\n  const timeframe = process.argv[3] || 'week';\n  \n  generateTestReport(format, timeframe)\n    .then(() => process.exit(0))\n    .catch(() => process.exit(1));\n}\n\nmodule.exports = generateTestReport;\n```\n\n3. 更新中間件以整合報告系統 `tests/run-with-reporting.js`:\n\n```javascript\n// tests/run-with-reporting.js\nconst TestTaskManager = require('./utils/task-manager');\nconst PlaywrightRunner = require('./utils/playwright-runner');\nconst TestingIntegrationMiddleware = require('./utils/integration-middleware');\nconst PlaywrightMCPIntegration = require('./utils/playwright-mcp-integration');\nconst TestReportingSystem = require('./utils/test-reporting');\n\nasync function runTestsWithReporting() {\n  let stopMonitoring = null;\n  \n  try {\n    // 初始化元件\n    const taskManager = new TestTaskManager();\n    const playwrightRunner = new PlaywrightRunner();\n    const middleware = new TestingIntegrationMiddleware(taskManager, playwrightRunner);\n    const mcpIntegration = new PlaywrightMCPIntegration();\n    const reportingSystem = new TestReportingSystem();\n    \n    await middleware.init();\n    await reportingSystem.init();\n    \n    // 開始監控\n    stopMonitoring = await mcpIntegration.startMonitoring(middleware);\n    \n    // 添加報告相關的事件監聽器\n    middleware.on('test:completed', async (data) => {\n      await reportingSystem.recordTestResult({\n        taskId: data.taskId,\n        status: 'completed',\n        duration: data.result.duration,\n        module: data.result.module || 'unknown',\n        timestamp: new Date().toISOString()\n      });\n    });\n    \n    middleware.on('test:failed', async (data) => {\n      await reportingSystem.recordTestResult({\n        taskId: data.taskId,\n        status: 'failed',\n        error: data.error,\n        module: data.module || 'unknown',\n        timestamp: new Date().toISOString()\n      });\n    });\n    \n    // 獲取並執行所有待處理的測試任務\n    console.log('Starting tests with reporting...');\n    const results = await middleware.scheduleTasks();\n    \n    // 輸出測試結果統計\n    const totalTests = results.length;\n    const passedTests = results.filter(r => r.status === 'completed').length;\n    const failedTests = results.filter(r => r.status === 'failed').length;\n    \n    console.log('\\nTest Execution Summary:');\n    console.log(`Total Tests: ${totalTests}`);\n    console.log(`Passed: ${passedTests}`);\n    console.log(`Failed: ${failedTests}`);\n    console.log(`Pass Rate: ${Math.round((passedTests / totalTests) * 100)}%`);\n    \n    // 生成HTML報告\n    console.log('\\nGenerating test report...');\n    const reportPath = await reportingSystem.generateReport('html', 'day');\n    console.log(`Report available at: ${reportPath}`);\n    \n    return results;\n  } catch (error) {\n    console.error('Error running tests with reporting:', error);\n    throw error;\n  } finally {\n    // 確保停止監控\n    if (stopMonitoring) {\n      stopMonitoring();\n    }\n  }\n}\n\n// 如果直接執行腳本\nif (require.main === module) {\n  runTestsWithReporting()\n    .then(() => process.exit(0))\n    .catch((error) => {\n      console.error('Test automation with reporting failed:', error);\n      process.exit(1);\n    });\n}\n\nmodule.exports = runTestsWithReporting;\n```\n\n4. 在 package.json 中添加相關腳本:\n\n```json\n\"scripts\": {\n  \"test:report\": \"node tests/generate-report.js\",\n  \"test:with-reporting\": \"node tests/run-with-reporting.js\"\n}\n```",
      "analysisResult": "為Chat with Me專案設計並實現整合shrimp-task-manager和playwright-mcp-server的自動化測試框架，覆蓋所有核心功能模組。"
    },
    {
      "id": "d14b84dd-c973-44a5-8e75-7b5553176996",
      "name": "實現核心功能測試案例",
      "description": "將為應用程式的核心功能實現測試案例，包括身份驗證、聊天功能、好友系統、AI功能及支付系統等模塊的端對端測試。",
      "status": "待處理",
      "dependencies": [],
      "createdAt": "2025-04-19T13:08:04.042Z",
      "updatedAt": "2025-04-19T13:08:04.042Z",
      "implementationGuide": "實現至少五個核心功能測試案例：\n\n1. **實現身份驗證測試** - 創建使用者註冊、登入和密碼重置的測試案例\n\n2. **實現聊天功能測試** - 測試創建對話、發送消息和媒體共享功能\n\n3. **實現好友系統測試** - 測試搜尋、添加好友和QR碼功能\n\n4. **實現AI功能測試** - 測試AI機器人互動和AI輔助回覆功能\n\n5. **實現支付系統測試** - 測試充值、數據查看和交易流程\n\n所有測試案例應使用已開發的TestCaseBuilder工具，並保存在tests/e2e目錄中。每個測試應包含測試步驟、結果驗證和錯誤處理。",
      "analysisResult": "為Chat with Me專案設計並實現整合shrimp-task-manager和playwright-mcp-server的自動化測試框架，覆蓋所有核心功能模組。"
    },
    {
      "id": "dfbc9bb9-8c61-4fad-a234-e9e97f49467d",
      "name": "系統整合與测試自動化部署",
      "description": "將所有测試系統組件進行最終整合，包括開發持續整合流程、定時執行腳本和監控儀表板。確保測試流程能夠自動化地執行並回報結果。",
      "status": "待處理",
      "dependencies": [],
      "createdAt": "2025-04-19T13:09:26.035Z",
      "updatedAt": "2025-04-19T13:09:26.035Z",
      "implementationGuide": "1. 建立測試整合執行腳本 `tests/ci-test-run.js`:\n\n```javascript\n// tests/ci-test-run.js\nconst TestTaskManager = require('./utils/task-manager');\nconst PlaywrightRunner = require('./utils/playwright-runner');\nconst TestingIntegrationMiddleware = require('./utils/integration-middleware');\nconst PlaywrightMCPIntegration = require('./utils/playwright-mcp-integration');\nconst TestReportingSystem = require('./utils/test-reporting');\nconst taskTemplates = require('./utils/task-templates');\n\nasync function setupAndRunTests() {\n  try {\n    console.log('======== CI Test Automation Run ========');\n    console.log('Step 1: Setting up test environment...');\n    \n    // 初始化所有組件\n    const taskManager = new TestTaskManager();\n    const playwrightRunner = new PlaywrightRunner({\n      headless: true // CI 環境中使用無頭模式\n    });\n    const middleware = new TestingIntegrationMiddleware(taskManager, playwrightRunner);\n    const mcpIntegration = new PlaywrightMCPIntegration();\n    const reportingSystem = new TestReportingSystem();\n    \n    await middleware.init();\n    await reportingSystem.init();\n    \n    // 開始監控\n    const stopMonitoring = await mcpIntegration.startMonitoring(middleware);\n    \n    console.log('Step 2: Setting up test tasks...');\n    // 清除之前的測試任務\n    const allTasks = await taskManager.getAllTasks();\n    for (const task of allTasks) {\n      // 只刪除狀態不是 completed 的任務\n      if (task.status !== 'completed') {\n        await taskManager.removeTask(task.id);\n      }\n    }\n    \n    // 創建新的測試任務\n    await taskManager.createTestTask(taskTemplates.authenticationTest());\n    await taskManager.createTestTask(taskTemplates.chatFunctionalityTest());\n    await taskManager.createTestTask(taskTemplates.aiFeaturesTest());\n    await taskManager.createTestTask(taskTemplates.friendsSystemTest());\n    await taskManager.createTestTask(taskTemplates.paymentSystemTest());\n    \n    // 設置事件監聽器\n    middleware.on('test:completed', async (data) => {\n      await reportingSystem.recordTestResult({\n        taskId: data.taskId,\n        status: 'completed',\n        duration: data.result.duration,\n        module: data.result.module || 'unknown',\n        timestamp: new Date().toISOString()\n      });\n    });\n    \n    middleware.on('test:failed', async (data) => {\n      await reportingSystem.recordTestResult({\n        taskId: data.taskId,\n        status: 'failed',\n        error: data.error,\n        module: data.module || 'unknown',\n        timestamp: new Date().toISOString()\n      });\n    });\n    \n    console.log('Step 3: Executing tests...');\n    const startTime = Date.now();\n    const results = await middleware.scheduleTasks();\n    const endTime = Date.now();\n    const totalDuration = (endTime - startTime) / 1000;\n    \n    // 輸出測試結果統計\n    const totalTests = results.length;\n    const passedTests = results.filter(r => r.status === 'completed').length;\n    const failedTests = results.filter(r => r.status === 'failed').length;\n    \n    console.log('\\n======== Test Execution Summary ========');\n    console.log(`Total Tests: ${totalTests}`);\n    console.log(`Passed: ${passedTests}`);\n    console.log(`Failed: ${failedTests}`);\n    console.log(`Pass Rate: ${Math.round((passedTests / totalTests) * 100)}%`);\n    console.log(`Total Duration: ${totalDuration.toFixed(2)} seconds`);\n    \n    // 生成報告\n    console.log('\\nStep 4: Generating test reports...');\n    const htmlReportPath = await reportingSystem.generateReport('html', 'day');\n    const jsonReportPath = await reportingSystem.generateReport('json', 'day');\n    \n    console.log(`HTML Report: ${htmlReportPath}`);\n    console.log(`JSON Report: ${jsonReportPath}`);\n    \n    // 停止監控\n    stopMonitoring();\n    \n    console.log('\\n======== CI Test Run Completed ========');\n    \n    // 返回完整結果\n    return {\n      totalTests,\n      passedTests,\n      failedTests,\n      passRate: Math.round((passedTests / totalTests) * 100),\n      duration: totalDuration,\n      reports: {\n        html: htmlReportPath,\n        json: jsonReportPath\n      }\n    };\n  } catch (error) {\n    console.error('CI Test run failed:', error);\n    throw error;\n  }\n}\n\n// 如果直接執行腳本\nif (require.main === module) {\n  setupAndRunTests()\n    .then(results => {\n      // 設置退出代碼，如果有測試失敗則返回非零值\n      if (results.failedTests > 0) {\n        process.exit(1);\n      } else {\n        process.exit(0);\n      }\n    })\n    .catch(error => {\n      console.error(error);\n      process.exit(1);\n    });\n}\n\nmodule.exports = setupAndRunTests;\n```\n\n2. 建立持續整合配置檔在 `.github/workflows/test-automation.yml`:\n\n```yaml\nname: Test Automation\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main, develop ]\n  # 允許手動觸發\n  workflow_dispatch:\n  # 定時執行 (每天凌晨3點)\n  schedule:\n    - cron: '0 3 * * *'\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Set up Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: 18\n        cache: 'npm'\n\n    - name: Install dependencies\n      run: npm ci\n\n    - name: Install Playwright browsers\n      run: npx playwright install --with-deps\n\n    - name: Run automated tests\n      run: npm run test:ci\n\n    - name: Upload test reports\n      if: always()\n      uses: actions/upload-artifact@v3\n      with:\n        name: test-reports\n        path: tests/reports/\n        retention-days: 7\n```\n\n3. 在 package.json 中新增相關腳本:\n\n```json\n\"scripts\": {\n  \"test:ci\": \"node tests/ci-test-run.js\",\n  \"test:schedule\": \"node -e \\\"require('./tests/utils/test-scheduler').scheduleTests()\\\"\"\n}\n```\n\n4. 創建定時測試排程模塊 `tests/utils/test-scheduler.js`:\n\n```javascript\n// tests/utils/test-scheduler.js\nconst cron = require('node-cron');\nconst path = require('path');\nconst fs = require('fs/promises');\nconst { execSync } = require('child_process');\n\nclass TestScheduler {\n  constructor(config = {}) {\n    this.config = {\n      scheduleFilePath: path.join(process.cwd(), 'tests', 'schedule.json'),\n      ...config\n    };\n    this.jobs = new Map();\n  }\n\n  // 載入測試排程\n  async loadSchedule() {\n    try {\n      const scheduleData = await fs.readFile(this.config.scheduleFilePath, 'utf8');\n      return JSON.parse(scheduleData);\n    } catch (error) {\n      console.warn('No schedule found or error loading schedule:', error.message);\n      // 返回默認排程\n      return {\n        schedules: [\n          {\n            name: 'Daily full test run',\n            cron: '0 3 * * *', // 每天凌晨3點AM\n            command: 'npm run test:ci'\n          },\n          {\n            name: 'Weekly report generation',\n            cron: '0 9 * * 1', // 每週一早9AM\n            command: 'npm run test:report -- html week'\n          }\n        ]\n      };\n    }\n  }\n\n  // 保存測試排程\n  async saveSchedule(schedule) {\n    await fs.writeFile(\n      this.config.scheduleFilePath, \n      JSON.stringify(schedule, null, 2), \n      'utf8'\n    );\n  }\n\n  // 啟動所有排程任務\n  async scheduleAllJobs() {\n    // 停止任何現有的工作\n    this.stopAllJobs();\n    \n    const schedule = await this.loadSchedule();\n    \n    for (const job of schedule.schedules) {\n      try {\n        // 確認 cron 表達式有效\n        if (!cron.validate(job.cron)) {\n          console.error(`Invalid cron expression for job ${job.name}: ${job.cron}`);\n          continue;\n        }\n        \n        console.log(`Scheduling job: ${job.name} with cron: ${job.cron}`);\n        \n        // 創建並儲存 cron 工作\n        const cronJob = cron.schedule(job.cron, () => {\n          console.log(`Executing scheduled job: ${job.name}`);\n          try {\n            execSync(job.command, { stdio: 'inherit' });\n            console.log(`Job ${job.name} completed successfully`);\n          } catch (error) {\n            console.error(`Error executing job ${job.name}:`, error.message);\n          }\n        });\n        \n        this.jobs.set(job.name, cronJob);\n      } catch (error) {\n        console.error(`Error scheduling job ${job.name}:`, error.message);\n      }\n    }\n    \n    console.log(`Scheduled ${this.jobs.size} jobs`);\n  }\n\n  // 停止所有排程任務\n  stopAllJobs() {\n    for (const [name, job] of this.jobs.entries()) {\n      console.log(`Stopping job: ${name}`);\n      job.stop();\n    }\n    \n    this.jobs.clear();\n  }\n\n  // 新增測試排程\n  async addTestSchedule(name, cronExpression, command) {\n    if (!cron.validate(cronExpression)) {\n      throw new Error(`Invalid cron expression: ${cronExpression}`);\n    }\n    \n    const schedule = await this.loadSchedule();\n    \n    // 檢查是否已存在同名排程\n    const existingIndex = schedule.schedules.findIndex(job => job.name === name);\n    if (existingIndex >= 0) {\n      schedule.schedules[existingIndex] = { name, cron: cronExpression, command };\n    } else {\n      schedule.schedules.push({ name, cron: cronExpression, command });\n    }\n    \n    await this.saveSchedule(schedule);\n    \n    // 重新啟動所有排程\n    await this.scheduleAllJobs();\n    \n    return { success: true, message: `Schedule ${name} added successfully` };\n  }\n\n  // 移除測試排程\n  async removeTestSchedule(name) {\n    const schedule = await this.loadSchedule();\n    \n    const initialLength = schedule.schedules.length;\n    schedule.schedules = schedule.schedules.filter(job => job.name !== name);\n    \n    if (schedule.schedules.length === initialLength) {\n      return { success: false, message: `Schedule ${name} not found` };\n    }\n    \n    await this.saveSchedule(schedule);\n    \n    // 停止現有工作\n    const job = this.jobs.get(name);\n    if (job) {\n      job.stop();\n      this.jobs.delete(name);\n    }\n    \n    return { success: true, message: `Schedule ${name} removed successfully` };\n  }\n}\n\n// 創建一個單例化定時器\n const scheduler = new TestScheduler();\n\n// 對外暸露的函數\nmodule.exports = {\n  // 開始計劃測試\n  scheduleTests: async () => {\n    await scheduler.scheduleAllJobs();\n    // 保持進程運行\n    console.log('Test scheduler is running. Press Ctrl+C to stop.');\n  },\n  \n  // 新增測試計劃\n  addTestSchedule: async (name, cronExpression, command) => {\n    return scheduler.addTestSchedule(name, cronExpression, command);\n  },\n  \n  // 移除測試計劃\n  removeTestSchedule: async (name) => {\n    return scheduler.removeTestSchedule(name);\n  },\n  \n  // 停止所有測試計劃\n  stopAllSchedules: () => {\n    scheduler.stopAllJobs();\n    return { success: true, message: 'All scheduled jobs stopped' };\n  }\n};\n```\n\n5. 添加所需依賴項，更新 package.json:\n\n```json\n\"dependencies\": {\n  \"node-cron\": \"^3.0.2\"\n}\n```",
      "analysisResult": "為Chat with Me專案設計並實現整合shrimp-task-manager和playwright-mcp-server的自動化測試框架，覆蓋所有核心功能模組。"
    }
  ]
}